클라이언트 구성을 보고 서버 구성을 제안하겠습니다.

## 서버 프로젝트 구조 제안

```typescript
synaptic-server/
├── src/
│   ├── domain/                 // 핵심 도메인 로직
│   │   ├── roadmap/           // 로드맵 도메인
│   │   │   ├── entities/      // 도메인 엔티티
│   │   │   ├── value-objects/ // 값 객체
│   │   │   ├── events/        // 도메인 이벤트
│   │   │   └── repositories/  // 레포지토리 인터페이스
│   │   ├── learning/          // 학습 도메인
│   │   ├── review/            // 복습 도메인
│   │   └── blog/              // 블로그 도메인
│   │
│   ├── application/           // 유스케이스 및 서비스
│   │   ├── roadmap/
│   │   │   ├── commands/      // 커맨드 핸들러
│   │   │   ├── queries/       // 쿼리 핸들러
│   │   │   ├── dto/          // DTO 정의
│   │   │   └── services/     // 응용 서비스
│   │   ├── learning/
│   │   ├── review/
│   │   └── blog/
│   │
│   ├── infrastructure/        // 인프라스트럭처 계층
│   │   ├── persistence/      // 데이터베이스 관련
│   │   │   ├── repositories/ // 구현체
│   │   │   ├── entities/     // ORM 엔티티
│   │   │   └── migrations/   // DB 마이그레이션
│   │   ├── cache/           // 캐시 관련
│   │   ├── messaging/       // 메시징 시스템
│   │   └── external/        // 외부 서비스 통합
│   │
│   ├── interfaces/           // 인터페이스 계층
│   │   ├── http/            // REST API
│   │   │   ├── controllers/
│   │   │   ├── middlewares/
│   │   │   └── validators/
│   │   ├── graphql/         // GraphQL API
│   │   └── websocket/       // WebSocket
│   │
│   └── shared/              // 공유 유틸리티
│       ├── utils/
│       ├── types/
│       └── constants/
│
├── test/                    // 테스트
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
└── config/                  // 설정 파일
```

## 주요 구현 예시

1. **도메인 계층**
```typescript
// src/domain/roadmap/entities/roadmap.entity.ts
@Entity()
export class Roadmap extends AggregateRoot {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @OneToMany(() => Node, node => node.roadmap)
  nodes: Node[];

  addNode(node: Node): void {
    this.nodes.push(node);
    this.addDomainEvent(new NodeAddedEvent(this, node));
  }

  updateProgress(nodeId: string, progress: number): void {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node) {
      node.updateProgress(progress);
      this.addDomainEvent(new ProgressUpdatedEvent(this, node));
    }
  }
}
```

2. **응용 계층**
```typescript
// src/application/roadmap/commands/create-roadmap.handler.ts
@CommandHandler(CreateRoadmapCommand)
export class CreateRoadmapHandler {
  constructor(
    private readonly roadmapRepository: RoadmapRepository,
    private readonly eventBus: EventBus
  ) {}

  @Transactional()
  async execute(command: CreateRoadmapCommand): Promise<string> {
    const roadmap = Roadmap.create(command);
    await this.roadmapRepository.save(roadmap);
    await this.eventBus.publishAll(roadmap.getDomainEvents());
    return roadmap.id;
  }
}
```

3. **인프라스트럭처 계층**
```typescript
// src/infrastructure/persistence/repositories/roadmap.repository.ts
@Injectable()
export class RoadmapRepositoryImpl implements RoadmapRepository {
  constructor(
    @InjectRepository(RoadmapEntity)
    private readonly repository: Repository<RoadmapEntity>,
    private readonly cacheManager: CacheManager
  ) {}

  async findById(id: string): Promise<Roadmap> {
    const cached = await this.cacheManager.get(`roadmap:${id}`);
    if (cached) return this.mapper.toDomain(cached);

    const entity = await this.repository.findOne(id);
    if (!entity) throw new NotFoundException();

    await this.cacheManager.set(`roadmap:${id}`, entity);
    return this.mapper.toDomain(entity);
  }
}
```

## 클라이언트와의 통합 포인트

1. **API 엔드포인트 정의**
```typescript
// src/interfaces/http/controllers/roadmap.controller.ts
@Controller('roadmaps')
export class RoadmapController {
  @Post()
  async createRoadmap(@Body() dto: CreateRoadmapDto) {
    return this.commandBus.execute(new CreateRoadmapCommand(dto));
  }

  @Get(':id')
  async getRoadmap(@Param('id') id: string) {
    return this.queryBus.execute(new GetRoadmapQuery(id));
  }

  @Patch(':id/progress')
  async updateProgress(
    @Param('id') id: string,
    @Body() dto: UpdateProgressDto
  ) {
    return this.commandBus.execute(
      new UpdateProgressCommand(id, dto)
    );
  }
}
```

2. **실시간 업데이트 처리**
```typescript
// src/interfaces/websocket/roadmap.gateway.ts
@WebSocketGateway()
export class RoadmapGateway {
  @SubscribeMessage('joinRoadmap')
  handleJoinRoadmap(client: Socket, roadmapId: string) {
    client.join(`roadmap:${roadmapId}`);
  }

  @OnEvent(ProgressUpdatedEvent.name)
  handleProgressUpdate(event: ProgressUpdatedEvent) {
    this.server.to(`roadmap:${event.roadmapId}`).emit(
      'progressUpdated',
      event.data
    );
  }
}
```

## 클라이언트 구성과의 충돌점 분석

1. **충돌하지 않는 부분**
- 기능별 모듈화 구조가 일치
- 도메인 중심 설계 원칙 일치
- 타입 정의와 인터페이스 구조 일치

2. **주의가 필요한 부분**
```typescript
// 클라이언트의 API 호출 구조
// src/core/api/client.ts
export class ApiClient {
  async get<T>(endpoint: string): Promise<T> {
    // API 요청 로직
  }
}

// 서버의 응답 구조
// src/interfaces/http/transformers/response.transformer.ts
@Injectable()
export class ResponseTransformer implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    return next.handle().pipe(
      map(data => ({
        success: true,
        data,
        timestamp: new Date().toISOString()
      }))
    );
  }
}
```

3. **해결 방안**
```typescript
// 공통 인터페이스 정의
// shared/types/api.ts
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  timestamp: string;
  error?: ApiError;
}

// 서버 측 구현
@Injectable()
export class ApiResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    return next.handle().pipe(
      map(data => ({
        success: true,
        data,
        timestamp: new Date().toISOString()
      }))
    );
  }
}

// 클라이언트 측 구현
export class ApiClient {
  async request<T>(endpoint: string): Promise<ApiResponse<T>> {
    const response = await fetch(endpoint);
    return response.json();
  }
}
```

이러한 구조는 클라이언트와 서버 간의 일관성을 유지하면서도, 각각의 책임을 명확히 분리할 수 있습니다. 특히 도메인 중심의 모듈화된 구조를 통해 양쪽의 개발 효율성과 유지보수성을 높일 수 있습니다.
