[회의실 A103, 프로젝트 아키텍처 검토 회의]

**프론트엔드 팀장**: 
안녕하세요. 서버팀에서 제안하신 프로젝트 구성 계획을 검토해봤는데, 몇 가지 우려되는 부분들이 있어서 논의하고 싶습니다.

첫째, API 응답 구조에 대해 말씀드리고 싶습니다.
```typescript
// 현재 제안된 서버 응답 구조
{
  success: boolean,
  data: T,
  timestamp: string
}
```
이 구조는 몇 가지 문제가 있습니다:
1. 페이지네이션 정보가 없습니다. 우리 로드맵이나 학습 컨텐츠는 무한 스크롤을 구현해야 하는데, 메타 정보가 필요합니다.
2. 에러 처리가 너무 단순합니다. `success` 플래그만으로는 부족합니다. 프론트엔드에서 다양한 에러 상황을 처리하기 위한 상세 정보가 필요합니다.

둘째, WebSocket 구현 방식이 너무 단순합니다:
```typescript
@WebSocketGateway()
export class RoadmapGateway {
  @SubscribeMessage('joinRoadmap')
  handleJoinRoadmap(client: Socket, roadmapId: string) {
    client.join(`roadmap:${roadmapId}`);
  }
}
```
실시간 협업 기능을 고려할 때:
1. 사용자 presence 정보가 없습니다
2. 작업 충돌 해결 메커니즘이 없습니다
3. 연결 재시도 전략이 보이지 않습니다

셋째, 캐싱 전략이 모호합니다:
```typescript
async findById(id: string): Promise<Roadmap> {
  const cached = await this.cacheManager.get(`roadmap:${id}`);
  if (cached) return this.mapper.toDomain(cached);
  // ...
}
```
- 캐시 무효화 전략이 없습니다
- 부분 업데이트 시 캐시 정책이 불분명합니다
- 클라이언트 사이드 캐싱과의 조화가 고려되지 않았습니다

다음과 같은 수정을 제안드립니다:

1. API 응답 구조 개선:
```typescript
interface ApiResponse<T> {
  data: T;
  meta: {
    pagination?: {
      currentPage: number;
      totalPages: number;
      totalItems: number;
      itemsPerPage: number;
    };
    timestamp: string;
  };
  error?: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
}
```

1. WebSocket 아키텍처 개선:
```typescript
interface CollaborationProtocol {
  presence: {
    join: (userData: UserPresence) => void;
    leave: () => void;
    update: (status: PresenceStatus) => void;
  };
  sync: {
    conflict: (resolution: ConflictResolution) => void;
    patch: (changes: JsonPatch) => void;
  };
  connection: {
    retry: RetryStrategy;
    heartbeat: () => void;
  };
}
```

1. 캐싱 전략 명확화:
```typescript
interface CacheStrategy {
  invalidation: {
    patterns: string[];
    triggers: CacheInvalidationTrigger[];
  };
  partial: {
    fields: string[];
    mergeStrategy: MergeStrategy;
  };
  sync: {
    clientTTL: number;
    revalidation: RevalidationStrategy;
  };
}
```

**프론트엔드 팀장**: 또한, 현재 구조에서는 API 버저닝에 대한 전략이 보이지 않습니다. 프로덕션 환경에서 API 변경을 어떻게 관리할 계획이신가요?

이러한 부분들이 명확하지 않으면 프론트엔드 개발 과정에서 많은 어려움을 겪을 수 있고, 특히 실시간 협업 기능 구현에서 심각한 문제가 발생할 수 있습니다.

이 부분들에 대해 서버팀의 의견을 듣고 싶습니다.

네, 프론트엔드 팀장님의 우려 사항에 대해 제 의견을 말씀드리겠습니다.

**1. API 응답 구조 관련**
```typescript
// 현재 우리의 응답 구조가 단순해 보일 수 있지만, 의도된 설계입니다.
interface ApiResponse<T> {
  success: boolean;
  data: T;
  timestamp: string;
}

// 페이지네이션이 필요한 경우
interface PaginatedData<T> {
  items: T[];
  pagination: {
    page: number;
    limit: number;
    totalItems: number;
    totalPages: number;
    hasNext: boolean;
  };
}
```

제가 이 구조를 고수하는 이유는:
1. 단순성과 일관성 - 모든 API 응답이 동일한 구조를 가집니다.
2. 페이지네이션은 `data` 내부에서 처리됩니다. 이는 응답 구조를 복잡하게 만들지 않으면서도 필요한 정보를 제공합니다.
3. 에러 처리는 HTTP 상태 코드와 함께 제공되며, 실패 시 `data` 필드에 상세 에러 정보가 포함됩니다.

**2. WebSocket 아키텍처**
```typescript
@WebSocketGateway()
export class CollaborationGateway {
  @SubscribeMessage('join')
  async handleJoin(client: Socket, payload: JoinPayload) {
    // 사용자 presence 관리
    await this.presenceManager.addUser(client.id, payload);
    
    // 작업 충돌 해결을 위한 Operational Transform 적용
    const operations = await this.otManager.getOperations(payload.roadmapId);
    return { operations, presence: await this.presenceManager.getUsers() };
  }

  @SubscribeMessage('operation')
  async handleOperation(client: Socket, operation: Operation) {
    const transformedOp = await this.otManager.transform(operation);
    this.server.to(operation.roadmapId).emit('operation', transformedOp);
  }
}
```

우리의 WebSocket 구현은:
1. Operational Transform을 통한 충돌 해결
2. Redis-based presence 시스템
3. 자동 재연결 및 상태 동기화
4. 작업 큐를 통한 순서 보장

이러한 기능들이 이미 계획되어 있습니다.

**3. 캐싱 전략**
```typescript
@Injectable()
export class CacheService {
  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private readonly eventBus: EventBus
  ) {
    // 이벤트 기반 캐시 무효화
    this.eventBus.subscribe(
      'entity.updated',
      async (event: EntityUpdatedEvent) => {
        await this.invalidateRelatedCaches(event);
      }
    );
  }

  async get<T>(key: string, factory: () => Promise<T>): Promise<T> {
    const cached = await this.cacheManager.get<T>(key);
    if (cached) return cached;

    const data = await factory();
    await this.cacheManager.set(key, data, {
      ttl: this.getTTL(key),
      tags: this.getTags(key)
    });

    return data;
  }

  private async invalidateRelatedCaches(event: EntityUpdatedEvent) {
    const tags = this.getRelatedTags(event);
    await this.cacheManager.invalidateByTags(tags);
  }
}
```

우리의 캐싱 전략은:
1. 태그 기반 캐시 무효화
2. 이벤트 기반 자동 캐시 갱신
3. 계층형 캐싱 (메모리 -> Redis -> DB)
4. 부분 캐시 업데이트 지원

**4. API 버저닝**
```typescript
@Controller('api/v1/roadmaps')
export class RoadmapController {
  @Version('1')
  @Get(':id')
  async getRoadmapV1(@Param('id') id: string) {
    return this.roadmapService.findById(id);
  }

  @Version('2')
  @Get(':id')
  async getRoadmapV2(@Param('id') id: string) {
    return this.roadmapService.findByIdWithEnhancements(id);
  }
}
```

API 버저닝은:
1. URL 기반 버저닝 (/api/v1/*, /api/v2/*)
2. 헤더 기반 버저닝 지원 (Accept-Version)
3. 하위 호환성 보장
4. 점진적 마이그레이션 지원

프론트엔드 팀의 우려는 이해하지만, 우리의 아키텍처는 이미 이러한 문제들을 고려하여 설계되었습니다. 다만, 문서화가 부족했던 점은 인정합니다. 

제안드리고 싶은 것은:
1. 서버-클라이언트 간 인터페이스 스펙 문서화 강화
2. 정기적인 아키텍처 리뷰 미팅 진행
3. 프로토타입을 통한 실제 구현 검증

이러한 방식으로 진행하면 어떨까요?

--- 
[모노레포 회의]



모노레포 구조를 활용한 프로젝트 구성을 제안드리겠습니다:

```typescript
synaptic/
├── .github/                    // GitHub 설정
│   └── workflows/              // CI/CD 파이프라인
│
├── packages/                   // 공유 패키지들
│   ├── types/                 // 공유 타입 정의
│   │   ├── package.json
│   │   ├── src/
│   │   │   ├── roadmap.ts
│   │   │   ├── learning.ts
│   │   │   └── api.ts
│   │   └── tsconfig.json
│   │
│   ├── utils/                 // 공유 유틸리티
│   │   ├── package.json
│   │   └── src/
│   │
│   └── config/               // 공유 설정
│       ├── package.json
│       └── src/
│
├── apps/
│   ├── client/               // 클라이언트 애플리케이션
│   │   ├── src/
│   │   │   ├── app/
│   │   │   ├── features/
│   │   │   ├── shared/
│   │   │   └── core/
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   └── server/              // 서버 애플리케이션
│       ├── src/
│       │   ├── domain/
│       │   ├── application/
│       │   ├── infrastructure/
│       │   └── interfaces/
│       ├── package.json
│       └── tsconfig.json
│
├── tools/                   // 개발 도구 및 스크립트
│   ├── generators/         // 코드 생성기
│   ├── scripts/           // 빌드/배포 스크립트
│   └── testing/           // 테스트 유틸리티
│
├── docs/                   // 프로젝트 문서
│   ├── api/
│   ├── architecture/
│   └── guides/
│
├── package.json           // 루트 package.json
├── turbo.json            // Turborepo 설정
├── nx.json               // Nx 설정 (선택적)
└── README.md
```

핵심 파일 예시:

1. **루트 package.json**
```json
{
  "name": "synaptic",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "turbo": "^1.10.0",
    "typescript": "^5.0.0"
  }
}
```

2. **공유 타입 정의 (packages/types/src/api.ts)**
```typescript
export interface ApiResponse<T> {
  data: T;
  meta: {
    pagination?: PaginationMeta;
    timestamp: string;
  };
  error?: ApiError;
}

export interface PaginationMeta {
  currentPage: number;
  totalPages: number;
  totalItems: number;
  itemsPerPage: number;
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, any>;
}
```

3. **turbo.json 설정**
```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "test": {
      "outputs": ["coverage/**"],
      "dependsOn": ["^build"]
    }
  }
}
```

4. **클라이언트-서버 통신 타입 (packages/types/src/websocket.ts)**
```typescript
export interface WebSocketEvents {
  // 실시간 협업
  'collaboration:join': (data: UserPresence) => void;
  'collaboration:leave': (userId: string) => void;
  'collaboration:update': (data: CollaborationUpdate) => void;

  // 실시간 알림
  'notification:received': (data: Notification) => void;
  'notification:read': (notificationId: string) => void;

  // 학습 진행
  'learning:progress': (data: LearningProgress) => void;
  'learning:complete': (data: LearningCompletion) => void;
}
```

이 구조의 장점:

1. **코드 공유와 재사용**
   - 타입 정의 공유
   - 유틸리티 함수 공유
   - 설정 공유

2. **개발 효율성**
   - 단일 저장소로 관리 용이
   - 통합 개발 환경
   - 의존성 관리 단순화

3. **빌드 최적화**
   - Turborepo를 통한 빌드 캐싱
   - 병렬 빌드 처리
   - 증분 빌드 지원

4. **품질 관리**
   - 통합 테스트 환경
   - 일관된 코드 스타일
   - 중앙화된 CI/CD

5. **확장성**
   - 새로운 패키지 추가 용이
   - 마이크로서비스 지원
   - 새로운 앱 추가 용이

이러한 구조는 클라이언트와 서버 팀이 효율적으로 협업할 수 있게 하며, 코드의 재사용성과 유지보수성을 크게 향상시킬 수 있습니다.
